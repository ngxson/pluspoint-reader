#include <errno.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <inttypes.h>
#include <string.h>
#include <assert.h>
#include <ctype.h>
#include <time.h>
#include <sys/time.h>
#include <math.h>
#include <fcntl.h>
#include <stddef.h>

#include "mquickjs.h"

#define BOOL int
#define TRUE 1
#define FALSE 0

static void dump_error(JSContext *ctx) {
  JSValue obj;
  obj = JS_GetException(ctx);
  JS_PrintValueF(ctx, obj, JS_DUMP_LONG);
  printf("\n");
}

static void js_log_func(void *opaque, const void *buf, size_t buf_len) {
  fwrite(buf, 1, buf_len, stderr);
}

static JSValue js_print(JSContext* ctx, JSValue* this_val, int argc, JSValue* argv) {
  return JS_UNDEFINED;
}

static JSValue js_date_now(JSContext* ctx, JSValue* this_val, int argc, JSValue* argv) {
  return JS_UNDEFINED;
}

static JSValue js_performance_now(JSContext* ctx, JSValue* this_val, int argc, JSValue* argv) {
  return JS_UNDEFINED;
}

static JSValue js_gc(JSContext* ctx, JSValue* this_val, int argc, JSValue* argv) {
  return JS_UNDEFINED;
}

static JSValue js_load(JSContext* ctx, JSValue* this_val, int argc, JSValue* argv) {
  return JS_UNDEFINED;
}

static JSValue js_setTimeout(JSContext* ctx, JSValue* this_val, int argc, JSValue* argv) {
  return JS_UNDEFINED;
}

static JSValue js_clearTimeout(JSContext* ctx, JSValue* this_val, int argc, JSValue* argv) {
  return JS_UNDEFINED;
}

#include "crosspoint_stdlib_stub.h"
#include "crosspoint_stdlib.h"

static uint8_t *load_file(const char *filename, int *plen) {
  FILE *f;
  uint8_t *buf;
  int buf_len;

  f = fopen(filename, "rb");
  if (!f) {
    perror(filename);
    exit(1);
  }
  fseek(f, 0, SEEK_END);
  buf_len = ftell(f);
  fseek(f, 0, SEEK_SET);
  buf = malloc(buf_len + 1);
  fread(buf, 1, buf_len, f);
  buf[buf_len] = '\0';
  fclose(f);
  if (plen)
    *plen = buf_len;
  return buf;
}

static void compile_file(const char *filename, const char *outfilename,
             size_t mem_size, int dump_memory, int parse_flags, BOOL force_32bit) {
  uint8_t *mem_buf;
  JSContext *ctx;
  char *eval_str;
  JSValue val;
  union {
      JSBytecodeHeader hdr;
#if JSW == 8
      JSBytecodeHeader32 hdr32;
#endif
  } hdr_buf;
  int hdr_len;
  const uint8_t *data_buf;
  uint32_t data_len;
  FILE *f;
  
  /* When compiling to a file, the actual content of the stdlib does
     not matter because the generated bytecode does not depend on
     it. We still need it so that the atoms for the parsing are
     defined. The JSContext must be discarded once the compilation
     is done. */
  mem_buf = malloc(mem_size);
  ctx = JS_NewContext2(mem_buf, mem_size, &js_stdlib, TRUE);
  JS_SetLogFunc(ctx, js_log_func);

  eval_str = (char *)load_file(filename, NULL);
  printf("Compiling %s to %s\n", filename, outfilename);
  printf("Input size: %zu bytes\n", strlen(eval_str));
  // printf("Contents:\n%s\n", eval_str);

  val = JS_Parse(ctx, eval_str, strlen(eval_str), filename, parse_flags);
  free(eval_str);
  if (JS_IsException(val)) {
    dump_error(ctx);
    return;
  }

#if JSW == 8 
  if (force_32bit) {
    if (JS_PrepareBytecode64to32(ctx, &hdr_buf.hdr32, &data_buf, &data_len, val)) {
      fprintf(stderr, "Could not convert the bytecode from 64 to 32 bits\n");
      exit(1);
    }
    hdr_len = sizeof(JSBytecodeHeader32);
  } else
#endif
  {
    JS_PrepareBytecode(ctx, &hdr_buf.hdr, &data_buf, &data_len, val);
    
    if (dump_memory)
      JS_DumpMemory(ctx, (dump_memory >= 2));
    
    /* Relocate to zero to have a deterministic
       output. JS_DumpMemory() cannot work once the heap is relocated,
       so we relocate after it. */
    JS_RelocateBytecode2(ctx, &hdr_buf.hdr, (uint8_t *)data_buf, data_len, 0, FALSE);
    hdr_len = sizeof(JSBytecodeHeader);
  }
  f = fopen(outfilename, "wb");
  if (!f) {
    perror(outfilename);
    exit(1);
  }
  fwrite(&hdr_buf, 1, hdr_len, f);
  fwrite(data_buf, 1, data_len, f);
  fclose(f);

  printf("Output size: %zu bytes\n", hdr_len + data_len);

  JS_FreeContext(ctx);
  free(mem_buf);
}

int main(int argc, char **argv) {
  char input_filename[256];
  char output_filename[256];
  size_t mem_size = 16 * 1024 * 1024;
  int dump_memory = 0;
  int parse_flags = 0;
  BOOL force_32bit = FALSE;

  if (argc < 2) {
    fprintf(stderr, "Usage: %s <input.js> [<output.bin>]\n", argv[0]);
    fprintf(stderr, "       if <output.bin> is not provided, the output will be <input>.bin\n");
    return 1;
  }

  // get input filename
  strncpy(input_filename, argv[1], sizeof(input_filename) - 1);
  input_filename[sizeof(input_filename) - 1] = '\0';

  // make sure input filename is .js
  if (strcmp(input_filename + strlen(input_filename) - 3, ".js") != 0) {
    fprintf(stderr, "Input filename must have a .js extension\n");
    return 1;
  }

  // check if output filename is provided, otherwise use <input>.bin
  if (argc >= 3) {
    strncpy(output_filename, argv[2], sizeof(output_filename) - 1);
    output_filename[sizeof(output_filename) - 1] = '\0';
  } else {
    // replace .js extension with .bin
    char *dot = strrchr(input_filename, '.');
    if (dot) {
      size_t base_len = dot - input_filename;
      if (base_len < sizeof(output_filename) - 5) { // 5 for ".bin" and null terminator
        strncpy(output_filename, input_filename, base_len);
        output_filename[base_len] = '\0';
        strcat(output_filename, ".bin");
      } else {
        fprintf(stderr, "Input filename is too long to generate output filename\n");
        return 1;
      }
    } else {
      fprintf(stderr, "Input filename does not have a .js extension\n");
      return 1;
    }
  }

  compile_file(input_filename, output_filename, mem_size, dump_memory, parse_flags, force_32bit);

  return 0;
}

